import os, filecmp

## Used to check a processed directory against another processed directory.
#
# 'ref_dir' is assumed to be correct, while 'test_dir' is a directory that is
# being tested for correctness. Files that are found in 'ref_dir', but not
# found in or different in 'test_dir', will be reported as errors.
#
# Files that are in 'test_dir' but not in 'ref_dir' are reported, but are not
# considered to be errors.
#
# * ref_dir: a reference directory.
# * test_dir: a directory generated by code that is being tested.
# * skip: A function that, if specified, should return true for files from ref_dir
#   that are to be skipped. This allows for ignoring files where differences are
#   irrelevant, such as log files. Defaults to not skipping any files.
def check_for_corresponding_files(ref_dir, test_dir, skip=lambda filename: False):
    for dirpath, dirnames, filenames in os.walk(ref_dir):
        for f in filenames:
            ref_file = os.path.join(ref_dir, dir, f)
            test_file = os.path.join(test_dir, get_rel_path(ref_dir, dir), f)
            if not os.path.isfile(test_file):
                print "x  ERROR: Test directory is missing file '%s'" % (ref_file)
            elif not filecmp.cmp(ref_file, test_file):
                print "x  ERROR: '%s' is not the same as '%s'" % (test_file, ref_file)
    # Check for extra files
    for dirpath, dirnames, filenames in os.walk(test_dir):
        for filename in filenames:
            path = os.path.join(ref_dir, get_rel_path(test_dir, dirpath), filename)
            if not (os.path.exists(path)):
                print "*  NOTE: File '%s' does not have a corresponding file in the reference directory" \
                      % (os.path.join(test_dir, dirpath, filename))

## Find the 'relative difference' between two paths.
#
# * root_path: a file path.
# * ext_path: a file path that starts with the root path.
# The result is a relative path that is that part of the
# ext_path not found in the root path.
# eg. 'get_rel_path("a/b", "a/b/c/d")' -> "c/d".
def get_rel_path(root_path, ext_path):
    if not ext_path.startswith(root_path):
        raise "Bad arguments to 'get_rel_path': %s and %s" %(root_path, ext_path)
    if not root_path.endswith("/"):
        root_path = root_path + "/"
    return ext_path[len(root_path):]

if __name__ == "__main__":
    assert get_rel_path("a/b", "a/b/c/d") == "c/d"
    assert get_rel_path("a/b/", "a/b/c/d") == "c/d"
